<html class="js csstransforms3d">
  <head>
    <meta charSet="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>
      F# Core API Docs | Async
    </title>
    <link rel="icon" type="image/png" sizes="32x32" href="https://baronfel.github.io/fsharp-core-api-docs//static/images/favicon.png"/>
    <link rel="stylesheet" href="https://baronfel.github.io/fsharp-core-api-docs//static/css/nucleus.css"/>
    <link rel="stylesheet" href="https://baronfel.github.io/fsharp-core-api-docs//static/css/fontawesome-all.min.css"/>
    <link rel="stylesheet" href="https://baronfel.github.io/fsharp-core-api-docs//static/css/hybrid.css"/>
    <link rel="stylesheet" href="https://baronfel.github.io/fsharp-core-api-docs//static/css/featherlight.min.css"/>
    <link rel="stylesheet" href="https://baronfel.github.io/fsharp-core-api-docs//static/css/perfect-scrollbar.min.css"/>
    <link rel="stylesheet" href="https://baronfel.github.io/fsharp-core-api-docs//static/css/auto-complete.css"/>
    <link rel="stylesheet" href="https://baronfel.github.io/fsharp-core-api-docs//static/css/atom-one-dark-reasonable.css"/>
    <link rel="stylesheet" href="https://baronfel.github.io/fsharp-core-api-docs//static/css/theme.css"/>
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.0/styles/atom-one-dark.min.css"/>
    <link rel="stylesheet" href="https://baronfel.github.io/fsharp-core-api-docs//static/css/theme-green.css"/>
    <script src="https://baronfel.github.io/fsharp-core-api-docs//static/js/jquery-3.3.1.min.js"></script>
  </head>
  <body>
    <nav id="sidebar">
      <div id="header-wrapper">
        <div id="header">
          <h2 id="logo">
            F# Core API Docs
          </h2>
        </div>
        <div class="searchbox">
          <label for="search-by">
            <i class="fas fa-search"></i>
          </label>
          <input data-search-input="" id="search-by" type="search" placeholder="Search..."/>
          <span data-search-clear="">
            <i class="fas fa-times"></i>
          </span>
        </div>
        <script type="text/javascript" src="https://baronfel.github.io/fsharp-core-api-docs//static/js/lunr.min.js"></script>
        <script type="text/javascript" src="https://baronfel.github.io/fsharp-core-api-docs//static/js/auto-complete.js"></script>
        <script type="text/javascript">
          var baseurl ='https://baronfel.github.io/fsharp-core-api-docs/'
        </script>
        <script type="text/javascript" src="https://baronfel.github.io/fsharp-core-api-docs//static/js/search.js"></script>
        <script src="https://baronfel.github.io/fsharp-core-api-docs//static/js/highlight.pack.js"></script>
        <script>
          hljs.initHighlightingOnLoad();
        </script>
      </div>
      <div class="highlightable">
        <ul class="topics">
          <li id="menu-refs" class="dd-item menu-group-link menu-group-link-active">
            <a>
              API References
            </a>
          </li>
        </ul>
        <ul id="submenu-refs" class="submenu submenu-active">
          <li>
            <a href="https://baronfel.github.io/fsharp-core-api-docs//reference/FSharp.Core/index.html" class="padding">
              FSharp.Core
            </a>
          </li>
        </ul>
        <section id="shortcuts">
          <h3>
            Shortcuts
          </h3>
          <ul>
            <li>
              <a class="padding" href="/fsharp-core-api-docs">
                <i class="fas fa-home"></i>
                Home
              </a>
            </li>
            <li>
              <a class="padding" href="http://fsharp.org">
                <i class="fas fa-cubes"></i>
                F# Software Foundation
              </a>
            </li>
            <li>
              <a class="padding" href="https://github.com/dotnet/fsharp">
                <i class="fab fa-github"></i>
                GitHub repo
              </a>
            </li>
          </ul>
        </section>
        <section id="footer">
          <p>Built with <a href="https://github.com/ionide/Fornax">Fornax</a>
        </section>
      </div>
    </nav>
    <section id="body">
      <div id="overlay"></div>
      <div class="padding highlightable">
        <div id="body-inner">
          <span id="sidebar-toggle-span">
            <a href="#" id="sidebar-toggle" data-sidebar-toggle="">
              <i class="fas fa-bars"></i>
               navigation
            </a>
          </span>
          <div class="api-page">
            <h2>
              Async
            </h2>
            <b>
              Namespace: 
            </b>
            <a href="Microsoft.FSharp.Control.html">
              Microsoft.FSharp.Control
            </a>
            <br/>
            <b>
              Parent: 
            </b>
            <a href="Microsoft.FSharp.Control.html">
              Microsoft.FSharp.Control
            </a>
            <span>
              <div class="comment"></br><p class='summary'>This static class holds members for creating and manipulating asynchronous computations.</p></div>
            </span>
            <br/>
            <b>
              Attributes:
            </b>
            <br/>
            <code>
              SealedAttribute
            </code>
            <br/>
            <code>
              CompiledNameAttribute
            </code>
            <br/>
            <table>
              <tr>
                <th width="35%">
                  Name
                </th>
                <th width="65%">
                  Description
                </th>
              </tr>
              <tr>
                <td colSpan="3">
                  <b>
                    Static Members
                  </b>
                </td>
              </tr>
              <tr>
                <td>
                  <code>
                    AsBeginEnd
                  </code>
                  <br/>
                  <br/>
                  <b>
                    Signature: 
                  </b>
                  (computation:('Arg -> Async<'T>)) -> ('Arg * AsyncCallback * obj -> IAsyncResult) * (IAsyncResult -> 'T) * (IAsyncResult -> unit)
                  <br/>
                </td>
                <td>
                  <div class="comment"></br><p class='summary'>Creates three functions that can be used to implement the .NET Asynchronous 
 Programming Model (APM) for a given asynchronous computation.</p><h2>Parameters</h2><dl><dt><span class='parameter'>computation</span></dt><dd><p>A function generating the asynchronous computation to split into the traditional
 .NET Asynchronous Programming Model.</p></dd></dl><p class='returns'>Returns: A tuple of the begin, end, and cancel members.</p><h2>Remarks</h2><p class='remarks'>The functions should normally be published as members with prefix ,
  and , and can be used within a type definition as follows:
 

 If the asynchronous computation takes no arguments, then AsBeginEnd is used as follows:
 


 If the asynchronous computation takes two arguments, then AsBeginEnd is used as follows:
 

 In each case, the resulting API will be familiar to programmers in other CLI languages and 
 is a useful way to publish asynchronous computations in CLI components.</p></div>
                </td>
              </tr>
              <tr>
                <td>
                  <code>
                    AwaitEvent
                  </code>
                  <br/>
                  <br/>
                  <b>
                    Signature: 
                  </b>
                  (event:IEvent<'Del,'T> * cancelAction:(unit -> unit) option) -> Async<'T>
                  <br/>
                </td>
                <td>
                  <div class="comment"></br><p class='summary'>Creates an asynchronous computation that waits for a single invocation of a CLI 
 event by adding a handler to the event. Once the computation completes or is 
 cancelled, the handler is removed from the event.</p><h2>Parameters</h2><dl><dt><span class='parameter'>event</span></dt><dd><p>The event to handle once.</p></dd><dt><span class='parameter'>cancelAction</span></dt><dd><p>An optional function to execute instead of cancelling when a
 cancellation is issued.</p></dd></dl><p class='returns'>Returns: An asynchronous computation that waits for the event to be invoked.</p><h2>Remarks</h2><p class='remarks'>The computation will respond to cancellation while waiting for the event. If a 
 cancellation occurs, and  is specified, then it is executed, and 
 the computation continues to wait for the event.
 
 If  is not specified, then cancellation causes the computation
 to cancel immediately.</p></div>
                </td>
              </tr>
              <tr>
                <td>
                  <code>
                    AwaitIAsyncResult
                  </code>
                  <br/>
                  <br/>
                  <b>
                    Signature: 
                  </b>
                  (iar:IAsyncResult * millisecondsTimeout:int option) -> Async<bool>
                  <br/>
                </td>
                <td>
                  <div class="comment"></br><p class='summary'>Creates an asynchronous computation that will wait on the IAsyncResult.</p><h2>Parameters</h2><dl><dt><span class='parameter'>iar</span></dt><dd><p>The IAsyncResult to wait on.</p></dd><dt><span class='parameter'>millisecondsTimeout</span></dt><dd><p>The timeout value in milliseconds.  If one is not provided
 then the default value of -1 corresponding to System.Threading.Timeout.Infinite.</p></dd></dl><p class='returns'>Returns: An asynchronous computation that waits on the given IAsyncResult.</p><h2>Remarks</h2><p class='remarks'>The computation returns true if the handle indicated a result within the given timeout.</p></div>
                </td>
              </tr>
              <tr>
                <td>
                  <code>
                    AwaitTask
                  </code>
                  <br/>
                  <br/>
                  <b>
                    Signature: 
                  </b>
                  task:Task -> Async<unit>
                  <br/>
                </td>
                <td>
                  <div class="comment"></br><p class='summary'>
 Return an asynchronous computation that will wait for the given task to complete and return
 its result.
</p></div>
                </td>
              </tr>
              <tr>
                <td>
                  <code>
                    AwaitTask
                  </code>
                  <br/>
                  <br/>
                  <b>
                    Signature: 
                  </b>
                  task:Task<'T> -> Async<'T>
                  <br/>
                </td>
                <td>
                  <div class="comment"></br><p class='summary'>
 Return an asynchronous computation that will wait for the given task to complete and return
 its result.
</p></div>
                </td>
              </tr>
              <tr>
                <td>
                  <code>
                    AwaitWaitHandle
                  </code>
                  <br/>
                  <br/>
                  <b>
                    Signature: 
                  </b>
                  (waitHandle:WaitHandle * millisecondsTimeout:int option) -> Async<bool>
                  <br/>
                </td>
                <td>
                  <div class="comment"></br><p class='summary'>Creates an asynchronous computation that will wait on the given WaitHandle.</p><h2>Parameters</h2><dl><dt><span class='parameter'>waitHandle</span></dt><dd><p>The WaitHandle that can be signalled.</p></dd><dt><span class='parameter'>millisecondsTimeout</span></dt><dd><p>The timeout value in milliseconds.  If one is not provided
 then the default value of -1 corresponding to System.Threading.Timeout.Infinite.</p></dd></dl><p class='returns'>Returns: An asynchronous computation that waits on the given WaitHandle.</p><h2>Remarks</h2><p class='remarks'>The computation returns true if the handle indicated a result within the given timeout.</p></div>
                </td>
              </tr>
              <tr>
                <td>
                  <code>
                    CancelDefaultToken
                  </code>
                  <br/>
                  <br/>
                  <b>
                    Signature: 
                  </b>
                  unit -> unit
                  <br/>
                </td>
                <td>
                  <div class="comment"></br><p class='summary'>Raises the cancellation condition for the most recent set of asynchronous computations started 
 without any specific CancellationToken. Replaces the global CancellationTokenSource with a new 
 global token source for any asynchronous computations created after this point without any 
 specific CancellationToken.</p></div>
                </td>
              </tr>
              <tr>
                <td>
                  <code>
                    Catch
                  </code>
                  <br/>
                  <br/>
                  <b>
                    Signature: 
                  </b>
                  computation:Async<'T> -> Async<Choice<'T,exn>>
                  <br/>
                </td>
                <td>
                  <div class="comment"></br><p class='summary'>Creates an asynchronous computation that executes .
 If this computation completes successfully then return  with the returned
 value. If this computation raises an exception before it completes then return 
 with the raised exception.</p><h2>Parameters</h2><dl><dt><span class='parameter'>computation</span></dt><dd><p>The input computation that returns the type T.</p></dd></dl><p class='returns'>Returns: A computation that returns a choice of type T or exception.</p></div>
                </td>
              </tr>
              <tr>
                <td>
                  <code>
                    Choice
                  </code>
                  <br/>
                  <br/>
                  <b>
                    Signature: 
                  </b>
                  (computations:seq<Async<'T option>>) -> Async<'T option>
                  <br/>
                </td>
                <td>
                  <div class="comment"></br><p class='summary'>Creates an asynchronous computation that executes all given asynchronous computations in parallel, 
 returning the result of the first succeeding computation (one whose result is 'Some x').
 If all child computations complete with None, the parent computation also returns None.</p><h2>Parameters</h2><dl><dt><span class='parameter'>computations</span></dt><dd><p>A sequence of computations to be parallelized.</p></dd></dl><p class='returns'>Returns: A computation that returns the first succeeding computation.</p><h2>Remarks</h2><p class='remarks'>
 If any child computation raises an exception, then the overall computation will trigger an 
 exception, and cancel the others. 

 The overall computation will respond to cancellation while executing the child computations.
 If cancelled, the computation will cancel any remaining child computations but will still wait
 for the other child computations to complete.</p></div>
                </td>
              </tr>
              <tr>
                <td>
                  <code>
                    FromBeginEnd
                  </code>
                  <br/>
                  <br/>
                  <b>
                    Signature: 
                  </b>
                  (arg1:'Arg1 * arg2:'Arg2 * arg3:'Arg3 * beginAction:('Arg1 * 'Arg2 * 'Arg3 * AsyncCallback * obj -> IAsyncResult) * endAction:(IAsyncResult -> 'T) * cancelAction:(unit -> unit) option) -> Async<'T>
                  <br/>
                </td>
                <td>
                  <div class="comment"></br><p class='summary'>Creates an asynchronous computation in terms of a Begin/End pair of actions in 
 the style used in CLI APIs. This overload should be used if the operation is 
 qualified by three arguments. For example, 
     
 When the computation is run,  is executed, with
 a callback which represents the continuation of the computation. 
 When the callback is invoked, the overall result is fetched using .</p><h2>Parameters</h2><dl><dt><span class='parameter'>arg1</span></dt><dd><p>The first argument for the operation.</p></dd><dt><span class='parameter'>arg2</span></dt><dd><p>The second argument for the operation.</p></dd><dt><span class='parameter'>arg3</span></dt><dd><p>The third argument for the operation.</p></dd><dt><span class='parameter'>beginAction</span></dt><dd><p>The function initiating a traditional CLI asynchronous operation.</p></dd><dt><span class='parameter'>endAction</span></dt><dd><p>The function completing a traditional CLI asynchronous operation.</p></dd><dt><span class='parameter'>cancelAction</span></dt><dd><p>An optional function to be executed when a cancellation is requested.</p></dd></dl><p class='returns'>Returns: An asynchronous computation wrapping the given Begin/End functions.</p><h2>Remarks</h2><p class='remarks'>The computation will respond to cancellation while waiting for the completion
 of the operation. If a cancellation occurs, and  is specified, then it is 
 executed, and the computation continues to wait for the completion of the operation.
 
 If  is not specified, then cancellation causes the computation
 to stop immediately, and subsequent invocations of the callback are ignored.</p></div>
                </td>
              </tr>
              <tr>
                <td>
                  <code>
                    FromBeginEnd
                  </code>
                  <br/>
                  <br/>
                  <b>
                    Signature: 
                  </b>
                  (arg1:'Arg1 * arg2:'Arg2 * beginAction:('Arg1 * 'Arg2 * AsyncCallback * obj -> IAsyncResult) * endAction:(IAsyncResult -> 'T) * cancelAction:(unit -> unit) option) -> Async<'T>
                  <br/>
                </td>
                <td>
                  <div class="comment"></br><p class='summary'>Creates an asynchronous computation in terms of a Begin/End pair of actions in 
 the style used in CLI APIs. This overload should be used if the operation is 
 qualified by two arguments. For example, 
     
 When the computation is run,  is executed, with
 a callback which represents the continuation of the computation. 
 When the callback is invoked, the overall result is fetched using .</p><h2>Parameters</h2><dl><dt><span class='parameter'>arg1</span></dt><dd><p>The first argument for the operation.</p></dd><dt><span class='parameter'>arg2</span></dt><dd><p>The second argument for the operation.</p></dd><dt><span class='parameter'>beginAction</span></dt><dd><p>The function initiating a traditional CLI asynchronous operation.</p></dd><dt><span class='parameter'>endAction</span></dt><dd><p>The function completing a traditional CLI asynchronous operation.</p></dd><dt><span class='parameter'>cancelAction</span></dt><dd><p>An optional function to be executed when a cancellation is requested.</p></dd></dl><p class='returns'>Returns: An asynchronous computation wrapping the given Begin/End functions.</p><h2>Remarks</h2><p class='remarks'>The computation will respond to cancellation while waiting for the completion
 of the operation. If a cancellation occurs, and  is specified, then it is 
 executed, and the computation continues to wait for the completion of the operation.
 
 If  is not specified, then cancellation causes the computation
 to stop immediately, and subsequent invocations of the callback are ignored.</p></div>
                </td>
              </tr>
              <tr>
                <td>
                  <code>
                    FromBeginEnd
                  </code>
                  <br/>
                  <br/>
                  <b>
                    Signature: 
                  </b>
                  (arg:'Arg1 * beginAction:('Arg1 * AsyncCallback * obj -> IAsyncResult) * endAction:(IAsyncResult -> 'T) * cancelAction:(unit -> unit) option) -> Async<'T>
                  <br/>
                </td>
                <td>
                  <div class="comment"></br><p class='summary'>Creates an asynchronous computation in terms of a Begin/End pair of actions in 
 the style used in CLI APIs. This overload should be used if the operation is 
 qualified by one argument. For example, 
     
 When the computation is run,  is executed, with
 a callback which represents the continuation of the computation. 
 When the callback is invoked, the overall result is fetched using .</p><h2>Parameters</h2><dl><dt><span class='parameter'>arg</span></dt><dd><p>The argument for the operation.</p></dd><dt><span class='parameter'>beginAction</span></dt><dd><p>The function initiating a traditional CLI asynchronous operation.</p></dd><dt><span class='parameter'>endAction</span></dt><dd><p>The function completing a traditional CLI asynchronous operation.</p></dd><dt><span class='parameter'>cancelAction</span></dt><dd><p>An optional function to be executed when a cancellation is requested.</p></dd></dl><p class='returns'>Returns: An asynchronous computation wrapping the given Begin/End functions.</p><h2>Remarks</h2><p class='remarks'>The computation will respond to cancellation while waiting for the completion
 of the operation. If a cancellation occurs, and  is specified, then it is 
 executed, and the computation continues to wait for the completion of the operation.
 
 If  is not specified, then cancellation causes the computation
 to stop immediately, and subsequent invocations of the callback are ignored.</p></div>
                </td>
              </tr>
              <tr>
                <td>
                  <code>
                    FromBeginEnd
                  </code>
                  <br/>
                  <br/>
                  <b>
                    Signature: 
                  </b>
                  (beginAction:(AsyncCallback * obj -> IAsyncResult) * endAction:(IAsyncResult -> 'T) * cancelAction:(unit -> unit) option) -> Async<'T>
                  <br/>
                </td>
                <td>
                  <div class="comment"></br><p class='summary'>Creates an asynchronous computation in terms of a Begin/End pair of actions in 
 the style used in CLI APIs. For example, 
     
 When the computation is run,  is executed, with
 a callback which represents the continuation of the computation. 
 When the callback is invoked, the overall result is fetched using .</p><h2>Parameters</h2><dl><dt><span class='parameter'>beginAction</span></dt><dd><p>The function initiating a traditional CLI asynchronous operation.</p></dd><dt><span class='parameter'>endAction</span></dt><dd><p>The function completing a traditional CLI asynchronous operation.</p></dd><dt><span class='parameter'>cancelAction</span></dt><dd><p>An optional function to be executed when a cancellation is requested.</p></dd></dl><p class='returns'>Returns: An asynchronous computation wrapping the given Begin/End functions.</p><h2>Remarks</h2><p class='remarks'>The computation will respond to cancellation while waiting for the completion
 of the operation. If a cancellation occurs, and  is specified, then it is 
 executed, and the computation continues to wait for the completion of the operation.
 
 If  is not specified, then cancellation causes the computation
 to stop immediately, and subsequent invocations of the callback are ignored.</p></div>
                </td>
              </tr>
              <tr>
                <td>
                  <code>
                    FromContinuations
                  </code>
                  <br/>
                  <br/>
                  <b>
                    Signature: 
                  </b>
                  (callback:(('T -> unit) * (exn -> unit) * (OperationCanceledException -> unit) -> unit)) -> Async<'T>
                  <br/>
                </td>
                <td>
                  <div class="comment"></br><p class='summary'>Creates an asynchronous computation that captures the current
 success, exception and cancellation continuations. The callback must 
 eventually call exactly one of the given continuations.</p><h2>Parameters</h2><dl><dt><span class='parameter'>callback</span></dt><dd><p>The function that accepts the current success, exception, and cancellation
 continuations.</p></dd></dl><p class='returns'>Returns: An asynchronous computation that provides the callback with the current continuations.</p></div>
                </td>
              </tr>
              <tr>
                <td>
                  <code>
                    Ignore
                  </code>
                  <br/>
                  <br/>
                  <b>
                    Signature: 
                  </b>
                  computation:Async<'T> -> Async<unit>
                  <br/>
                </td>
                <td>
                  <div class="comment"></br><p class='summary'>Creates an asynchronous computation that runs the given computation and ignores 
 its result.</p><h2>Parameters</h2><dl><dt><span class='parameter'>computation</span></dt><dd><p>The input computation.</p></dd></dl><p class='returns'>Returns: A computation that is equivalent to the input computation, but disregards the result.</p></div>
                </td>
              </tr>
              <tr>
                <td>
                  <code>
                    OnCancel
                  </code>
                  <br/>
                  <br/>
                  <b>
                    Signature: 
                  </b>
                  (interruption:(unit -> unit)) -> Async<IDisposable>
                  <br/>
                </td>
                <td>
                  <div class="comment"></br><p class='summary'>Generates a scoped, cooperative cancellation handler for use within an asynchronous workflow.</p><h2>Parameters</h2><dl><dt><span class='parameter'>interruption</span></dt><dd><p>The function that is executed on the thread performing the
 cancellation.</p></dd></dl><p class='returns'>Returns: An asynchronous computation that triggers the interruption if it is cancelled
 before being disposed.</p><h2>Remarks</h2><p class='remarks'>For example,
      
 generates an asynchronous computation where, if a cancellation happens any time during 
 the execution of the asynchronous computation in the scope of , then action 
  is executed on the thread that is performing the cancellation. This can 
 be used to arrange for a computation to be asynchronously notified that a cancellation 
 has occurred, e.g. by setting a flag, or deregistering a pending I/O action.</p></div>
                </td>
              </tr>
              <tr>
                <td>
                  <code>
                    Parallel
                  </code>
                  <br/>
                  <br/>
                  <b>
                    Signature: 
                  </b>
                  (computations:seq<Async<'T>> * maxDegreeOfParallelism:int option) -> Async<'T []>
                  <br/>
                </td>
                <td>
                  <div class="comment"></br><p class='summary'>Creates an asynchronous computation that executes all the given asynchronous computations,
 initially queueing each as work items and using a fork/join pattern.</p><h2>Parameters</h2><dl><dt><span class='parameter'>computations</span></dt><dd><p>A sequence of distinct computations to be parallelized.</p></dd></dl><p class='returns'>Returns: A computation that returns an array of values from the sequence of input computations.</p><h2>Remarks</h2><p class='remarks'>If all child computations succeed, an array of results is passed to the success continuation.

 If any child computation raises an exception, then the overall computation will trigger an
 exception, and cancel the others.

 The overall computation will respond to cancellation while executing the child computations.
 If cancelled, the computation will cancel any remaining child computations but will still wait
 for the other child computations to complete.</p></div>
                </td>
              </tr>
              <tr>
                <td>
                  <code>
                    Parallel
                  </code>
                  <br/>
                  <br/>
                  <b>
                    Signature: 
                  </b>
                  computations:seq<Async<'T>> -> Async<'T []>
                  <br/>
                </td>
                <td>
                  <div class="comment"></br><p class='summary'>Creates an asynchronous computation that executes all the given asynchronous computations, 
 initially queueing each as work items and using a fork/join pattern.</p><h2>Parameters</h2><dl><dt><span class='parameter'>computations</span></dt><dd><p>A sequence of distinct computations to be parallelized.</p></dd></dl><p class='returns'>Returns: A computation that returns an array of values from the sequence of input computations.</p><h2>Remarks</h2><p class='remarks'>If all child computations succeed, an array of results is passed to the success continuation.
 
 If any child computation raises an exception, then the overall computation will trigger an 
 exception, and cancel the others. 

 The overall computation will respond to cancellation while executing the child computations.
 If cancelled, the computation will cancel any remaining child computations but will still wait
 for the other child computations to complete.</p></div>
                </td>
              </tr>
              <tr>
                <td>
                  <code>
                    RunSynchronously
                  </code>
                  <br/>
                  <br/>
                  <b>
                    Signature: 
                  </b>
                  (computation:Async<'T> * timeout:int option * cancellationToken:CancellationToken option) -> 'T
                  <br/>
                </td>
                <td>
                  <div class="comment"></br><p class='summary'>Runs the asynchronous computation and await its result.</p><h2>Parameters</h2><dl><dt><span class='parameter'>computation</span></dt><dd><p>The computation to run.</p></dd><dt><span class='parameter'>timeout</span></dt><dd><p>The amount of time in milliseconds to wait for the result of the
 computation before raising a System.TimeoutException.  If no value is provided
 for timeout then a default of -1 is used to correspond to System.Threading.Timeout.Infinite.
 If a cancellable cancellationToken is provided, timeout parameter will be ignored</p></dd><dt><span class='parameter'>cancellationToken</span></dt><dd><p>The cancellation token to be associated with the computation.
 If one is not supplied, the default cancellation token is used.</p></dd></dl><p class='returns'>Returns: The result of the computation.</p><h2>Remarks</h2><p class='remarks'>If an exception occurs in the asynchronous computation then an exception is re-raised by this
 function.
        
 If no cancellation token is provided then the default cancellation token is used.

 The timeout parameter is given in milliseconds.  A value of -1 is equivalent to
 System.Threading.Timeout.Infinite.</p></div>
                </td>
              </tr>
              <tr>
                <td>
                  <code>
                    Sequential
                  </code>
                  <br/>
                  <br/>
                  <b>
                    Signature: 
                  </b>
                  computations:seq<Async<'T>> -> Async<'T []>
                  <br/>
                </td>
                <td>
                  <div class="comment"></br><p class='summary'>Creates an asynchronous computation that executes all the given asynchronous computations sequentially.</p><h2>Parameters</h2><dl><dt><span class='parameter'>computations</span></dt><dd><p>A sequence of distinct computations to be run in sequence.</p></dd></dl><p class='returns'>Returns: A computation that returns an array of values from the sequence of input computations.</p><h2>Remarks</h2><p class='remarks'>If all child computations succeed, an array of results is passed to the success continuation.

 If any child computation raises an exception, then the overall computation will trigger an
 exception, and cancel the others.

 The overall computation will respond to cancellation while executing the child computations.
 If cancelled, the computation will cancel any remaining child computations but will still wait
 for the other child computations to complete.</p></div>
                </td>
              </tr>
              <tr>
                <td>
                  <code>
                    Sleep
                  </code>
                  <br/>
                  <br/>
                  <b>
                    Signature: 
                  </b>
                  millisecondsDueTime:int -> Async<unit>
                  <br/>
                </td>
                <td>
                  <div class="comment"></br><p class='summary'>Creates an asynchronous computation that will sleep for the given time. This is scheduled
 using a System.Threading.Timer object. The operation will not block operating system threads
 for the duration of the wait.</p><h2>Parameters</h2><dl><dt><span class='parameter'>millisecondsDueTime</span></dt><dd><p>The number of milliseconds to sleep.</p></dd></dl><p class='returns'>Returns: An asynchronous computation that will sleep for the given time.</p></div>
                </td>
              </tr>
              <tr>
                <td>
                  <code>
                    Start
                  </code>
                  <br/>
                  <br/>
                  <b>
                    Signature: 
                  </b>
                  (computation:Async<unit> * cancellationToken:CancellationToken option) -> unit
                  <br/>
                </td>
                <td>
                  <div class="comment"></br><p class='summary'>Starts the asynchronous computation in the thread pool. Do not await its result.</p><h2>Parameters</h2><dl><dt><span class='parameter'>computation</span></dt><dd><p>The computation to run asynchronously.</p></dd><dt><span class='parameter'>cancellationToken</span></dt><dd><p>The cancellation token to be associated with the computation.
 If one is not supplied, the default cancellation token is used.</p></dd></dl><h2>Remarks</h2><p class='remarks'>If no cancellation token is provided then the default cancellation token is used.</p></div>
                </td>
              </tr>
              <tr>
                <td>
                  <code>
                    StartAsTask
                  </code>
                  <br/>
                  <br/>
                  <b>
                    Signature: 
                  </b>
                  (computation:Async<'T> * taskCreationOptions:TaskCreationOptions option * cancellationToken:CancellationToken option) -> Task<'T>
                  <br/>
                </td>
                <td>
                  <div class="comment"></br><p class='summary'>Executes a computation in the thread pool.</p><p class='returns'>Returns: A System.Threading.Tasks.Task that will be completed
 in the corresponding state once the computation terminates (produces the result, throws exception or gets canceled)</p><h2>Remarks</h2><p class='remarks'>If no cancellation token is provided then the default cancellation token is used.</p></div>
                </td>
              </tr>
              <tr>
                <td>
                  <code>
                    StartChild
                  </code>
                  <br/>
                  <br/>
                  <b>
                    Signature: 
                  </b>
                  (computation:Async<'T> * millisecondsTimeout:int option) -> Async<Async<'T>>
                  <br/>
                </td>
                <td>
                  <div class="comment"></br><p class='summary'>Starts a child computation within an asynchronous workflow. 
 This allows multiple asynchronous computations to be executed simultaneously.</p><h2>Parameters</h2><dl><dt><span class='parameter'>computation</span></dt><dd><p>The child computation.</p></dd><dt><span class='parameter'>millisecondsTimeout</span></dt><dd><p>The timeout value in milliseconds.  If one is not provided
 then the default value of -1 corresponding to System.Threading.Timeout.Infinite.</p></dd></dl><p class='returns'>Returns: A new computation that waits for the input computation to finish.</p><h2>Remarks</h2><p class='remarks'>This method should normally be used as the immediate 
 right-hand-side of a  binding in an F# asynchronous workflow, that is,
 
        async { ...
                let! completor1 = childComputation1 |> Async.StartChild  
                let! completor2 = childComputation2 |> Async.StartChild  
                ... 
                let! result1 = completor1 
                let! result2 = completor2 
                ... }
 
 When used in this way, each use of  starts an instance of  
 and returns a completor object representing a computation to wait for the completion of the operation.
 When executed, the completor awaits the completion of .</p></div>
                </td>
              </tr>
              <tr>
                <td>
                  <code>
                    StartChildAsTask
                  </code>
                  <br/>
                  <br/>
                  <b>
                    Signature: 
                  </b>
                  (computation:Async<'T> * taskCreationOptions:TaskCreationOptions option) -> Async<Task<'T>>
                  <br/>
                </td>
                <td>
                  <div class="comment"></br><p class='summary'>Creates an asynchronous computation which starts the given computation as a </p></div>
                </td>
              </tr>
              <tr>
                <td>
                  <code>
                    StartImmediate
                  </code>
                  <br/>
                  <br/>
                  <b>
                    Signature: 
                  </b>
                  (computation:Async<unit> * cancellationToken:CancellationToken option) -> unit
                  <br/>
                </td>
                <td>
                  <div class="comment"></br><p class='summary'>Runs an asynchronous computation, starting immediately on the current operating system
 thread.</p><h2>Parameters</h2><dl><dt><span class='parameter'>computation</span></dt><dd><p>The asynchronous computation to execute.</p></dd><dt><span class='parameter'>cancellationToken</span></dt><dd><p>The CancellationToken to associate with the computation.
 The default is used if this parameter is not provided.</p></dd></dl><h2>Remarks</h2><p class='remarks'>If no cancellation token is provided then the default cancellation token is used.</p></div>
                </td>
              </tr>
              <tr>
                <td>
                  <code>
                    StartImmediateAsTask
                  </code>
                  <br/>
                  <br/>
                  <b>
                    Signature: 
                  </b>
                  (computation:Async<'T> * cancellationToken:CancellationToken option) -> Task<'T>
                  <br/>
                </td>
                <td>
                  <div class="comment"></br><p class='summary'>Runs an asynchronous computation, starting immediately on the current operating system
 thread, but also returns the execution as </p><h2>Parameters</h2><dl><dt><span class='parameter'>computation</span></dt><dd><p>The asynchronous computation to execute.</p></dd><dt><span class='parameter'>cancellationToken</span></dt><dd><p>The CancellationToken to associate with the computation.
 The default is used if this parameter is not provided.</p></dd></dl><p class='returns'>Returns: A System.Threading.Tasks.Task that will be completed
 in the corresponding state once the computation terminates (produces the result, throws exception or gets canceled)</p><h2>Remarks</h2><p class='remarks'>If no cancellation token is provided then the default cancellation token is used.
 You may prefer using this method if you want to achive a similar behviour to async await in C# as 
 async computation starts on the current thread with an ability to return a result.
 </p></div>
                </td>
              </tr>
              <tr>
                <td>
                  <code>
                    StartWithContinuations
                  </code>
                  <br/>
                  <br/>
                  <b>
                    Signature: 
                  </b>
                  (computation:Async<'T> * continuation:('T -> unit) * exceptionContinuation:(exn -> unit) * cancellationContinuation:(OperationCanceledException -> unit) * cancellationToken:CancellationToken option) -> unit
                  <br/>
                </td>
                <td>
                  <div class="comment"></br><p class='summary'>Runs an asynchronous computation, starting immediately on the current operating system
 thread. Call one of the three continuations when the operation completes.</p><h2>Parameters</h2><dl><dt><span class='parameter'>computation</span></dt><dd><p>The asynchronous computation to execute.</p></dd><dt><span class='parameter'>continuation</span></dt><dd><p>The function called on success.</p></dd><dt><span class='parameter'>exceptionContinuation</span></dt><dd><p>The function called on exception.</p></dd><dt><span class='parameter'>cancellationContinuation</span></dt><dd><p>The function called on cancellation.</p></dd><dt><span class='parameter'>cancellationToken</span></dt><dd><p>The CancellationToken to associate with the computation.
 The default is used if this parameter is not provided.</p></dd></dl><h2>Remarks</h2><p class='remarks'>If no cancellation token is provided then the default cancellation token
 is used.</p></div>
                </td>
              </tr>
              <tr>
                <td>
                  <code>
                    SwitchToContext
                  </code>
                  <br/>
                  <br/>
                  <b>
                    Signature: 
                  </b>
                  syncContext:SynchronizationContext -> Async<unit>
                  <br/>
                </td>
                <td>
                  <div class="comment"></br><p class='summary'>Creates an asynchronous computation that runs
 its continuation using syncContext.Post. If syncContext is null 
 then the asynchronous computation is equivalent to SwitchToThreadPool().</p><h2>Parameters</h2><dl><dt><span class='parameter'>syncContext</span></dt><dd><p>The synchronization context to accept the posted computation.</p></dd></dl><p class='returns'>Returns: An asynchronous computation that uses the syncContext context to execute.</p></div>
                </td>
              </tr>
              <tr>
                <td>
                  <code>
                    SwitchToNewThread
                  </code>
                  <br/>
                  <br/>
                  <b>
                    Signature: 
                  </b>
                  unit -> Async<unit>
                  <br/>
                </td>
                <td>
                  <div class="comment"></br><p class='summary'>Creates an asynchronous computation that creates a new thread and runs
 its continuation in that thread.</p><p class='returns'>Returns: A computation that will execute on a new thread.</p></div>
                </td>
              </tr>
              <tr>
                <td>
                  <code>
                    SwitchToThreadPool
                  </code>
                  <br/>
                  <br/>
                  <b>
                    Signature: 
                  </b>
                  unit -> Async<unit>
                  <br/>
                </td>
                <td>
                  <div class="comment"></br><p class='summary'>Creates an asynchronous computation that queues a work item that runs
 its continuation.</p><p class='returns'>Returns: A computation that generates a new work item in the thread pool.</p></div>
                </td>
              </tr>
              <tr>
                <td>
                  <code>
                    TryCancelled
                  </code>
                  <br/>
                  <br/>
                  <b>
                    Signature: 
                  </b>
                  (computation:Async<'T> * compensation:(OperationCanceledException -> unit)) -> Async<'T>
                  <br/>
                </td>
                <td>
                  <div class="comment"></br><p class='summary'>Creates an asynchronous computation that executes .
 If this computation is cancelled before it completes then the computation generated by 
 running  is executed.</p><h2>Parameters</h2><dl><dt><span class='parameter'>computation</span></dt><dd><p>The input asynchronous computation.</p></dd><dt><span class='parameter'>compensation</span></dt><dd><p>The function to be run if the computation is cancelled.</p></dd></dl><p class='returns'>Returns: An asynchronous computation that runs the compensation if the input computation
 is cancelled.</p></div>
                </td>
              </tr>
              <tr>
                <td>
                  <code>
                    DefaultCancellationToken
                  </code>
                  <br/>
                  <br/>
                  <b>
                    Signature: 
                  </b>
                  CancellationToken
                  <br/>
                </td>
                <td>
                  <div class="comment"></br><p class='summary'>Gets the default cancellation token for executing asynchronous computations.</p><p class='returns'>Returns: The default CancellationToken.</p></div>
                </td>
              </tr>
              <tr>
                <td>
                  <code>
                    CancellationToken
                  </code>
                  <br/>
                  <br/>
                  <b>
                    Signature: 
                  </b>
                  Async<CancellationToken>
                  <br/>
                </td>
                <td>
                  <div class="comment"></br><p class='summary'>Creates an asynchronous computation that returns the CancellationToken governing the execution 
 of the computation.</p><p class='returns'>Returns: An asynchronous computation capable of retrieving the CancellationToken from a computation
 expression.</p><h2>Remarks</h2><p class='remarks'>In  token can be used to initiate other 
 asynchronous operations that will cancel cooperatively with this workflow.</p></div>
                </td>
              </tr>
            </table>
          </div>
        </div>
      </div>
    </section>
    <div style="left: -1000px; overflow: scroll; position: absolute; top: -1000px; border: none; box-sizing: content-box; height: 200px; margin: 0px; padding: 0px; width: 200px;">
      <div style="border: none; box-sizing: content-box; height: 200px; margin: 0px; padding: 0px; width: 200px;"></div>
    </div>
    <script src="https://baronfel.github.io/fsharp-core-api-docs//static/js/clipboard.min.js"></script>
    <script src="https://baronfel.github.io/fsharp-core-api-docs//static/js/perfect-scrollbar.min.js"></script>
    <script src="https://baronfel.github.io/fsharp-core-api-docs//static/js/perfect-scrollbar.jquery.min.js"></script>
    <script src="https://baronfel.github.io/fsharp-core-api-docs//static/js/jquery.sticky.js"></script>
    <script src="https://baronfel.github.io/fsharp-core-api-docs//static/js/featherlight.min.js"></script>
    <script src="https://baronfel.github.io/fsharp-core-api-docs//static/js/modernizr.custom-3.6.0.js"></script>
    <script src="https://baronfel.github.io/fsharp-core-api-docs//static/js/learn.js"></script>
    <script src="https://baronfel.github.io/fsharp-core-api-docs//static/js/hugo-learn.js"></script>
    <link rel="stylesheet" href="https://baronfel.github.io/fsharp-core-api-docs//static/mermaid/mermaid.css"/>
    <script src="https://baronfel.github.io/fsharp-core-api-docs//static/mermaid/mermaid.js"></script>
    <script>
      mermaid.initialize({ startOnLoad: true });
    </script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.0/languages/fsharp.min.js"></script>
    <script>
      hljs.initHighlightingOnLoad()
    </script>
  </body>
</html>